#!/usr/bin/env python3
"""
Generate Version.h from library.json.
Called automatically by PlatformIO before each build.
"""

import json
import os
import subprocess
from datetime import datetime
from pathlib import Path


def get_git_info(project_root):
    """Get git commit hash and dirty status."""
    try:
        # Get short commit hash
        result = subprocess.run(
            ["git", "rev-parse", "--short", "HEAD"],
            cwd=project_root,
            capture_output=True,
            text=True,
            timeout=2
        )
        commit = result.stdout.strip() if result.returncode == 0 else "unknown"
        
        # Check if working tree is dirty
        result = subprocess.run(
            ["git", "diff", "--quiet"],
            cwd=project_root,
            timeout=2
        )
        dirty = result.returncode != 0
        
        return commit, dirty
    except Exception:
        return "unknown", False


def main():
    # Find project root (where library.json lives)
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    
    library_json = project_root / "library.json"
    version_h = project_root / "include" / "YourLibrary" / "Version.h"
    
    # Read version from library.json
    with open(library_json, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    version = data.get("version", "0.0.0")
    parts = version.split(".")
    major = int(parts[0]) if len(parts) > 0 else 0
    minor = int(parts[1]) if len(parts) > 1 else 0
    patch = int(parts[2]) if len(parts) > 2 else 0
    
    # Build metadata
    build_date = datetime.now().strftime("%Y-%m-%d")
    build_time = datetime.now().strftime("%H:%M:%S")
    build_timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Git info
    git_commit, git_dirty = get_git_info(project_root)
    git_status = "dirty" if git_dirty else "clean"
    
    # Generate Version.h
    content = f'''/**
 * @file Version.h
 * @brief Library version information.
 * 
 * This file is AUTO-GENERATED by scripts/generate_version.py from library.json.
 * DO NOT EDIT MANUALLY. Update version in library.json instead.
 * 
 * Generated: {build_timestamp}
 * Git commit: {git_commit} ({git_status})
 */

#pragma once

#include <stdint.h>

namespace YourLibrary {{

/// @brief Major version (breaking changes).
static constexpr uint16_t VERSION_MAJOR = {major};

/// @brief Minor version (new features, backward compatible).
static constexpr uint16_t VERSION_MINOR = {minor};

/// @brief Patch version (bug fixes).
static constexpr uint16_t VERSION_PATCH = {patch};

/// @brief Full version string (e.g., "1.2.3").
static constexpr const char* VERSION = "{version}";

/// @brief Encoded version for numeric comparison.
/// @note Format: MAJOR*10000 + MINOR*100 + PATCH
/// @note Example: version 1.2.3 = 10203
static constexpr uint32_t VERSION_CODE = {major * 10000 + minor * 100 + patch};

/// @brief Build date (YYYY-MM-DD).
static constexpr const char* BUILD_DATE = "{build_date}";

/// @brief Build time (HH:MM:SS).
static constexpr const char* BUILD_TIME = "{build_time}";

/// @brief Full build timestamp.
static constexpr const char* BUILD_TIMESTAMP = "{build_timestamp}";

/// @brief Git commit hash (short).
static constexpr const char* GIT_COMMIT = "{git_commit}";

/// @brief Git working tree status ("clean" or "dirty").
/// @note "dirty" means there are uncommitted changes.
static constexpr const char* GIT_STATUS = "{git_status}";

/// @brief Full version string with build info.
/// @note Format: "version (commit, date time)"
static constexpr const char* VERSION_FULL = "{version} ({git_commit}, {build_timestamp})";

}}  // namespace YourLibrary
'''
    
    # Write Version.h
    version_h.parent.mkdir(parents=True, exist_ok=True)
    with open(version_h, "w", encoding="utf-8") as f:
        f.write(content)
    
    print(f"Generated {version_h} with version {version}")


if __name__ == "__main__":
    main()
